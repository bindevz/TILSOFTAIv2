###############################################################################
# TILSOFTAI - Deep Analytics Workflow Integration Patch Pack
# Version: 1.0.0
# Date: 2026-02-04
# Target: C# Orchestration + SQL Server Enterprise Architecture
#
# CRITICAL: This patch pack follows enterprise end-to-end standards.
#           Agent MUST NOT create versioned files (no _v2, _backup, _old suffixes)
#           All changes are IN-PLACE modifications or additive NEW files only.
###############################################################################

schema_version: "1.0"
patch_id: "deep_analytics_integration"
title: "Deep Analytics Workflow Integration - Catalog-Driven Schema RAG + Insight Assembly"
language: "vi"
project: "TILSOFTAI"
created_at: "2026-02-04"

###############################################################################
# EXECUTIVE SUMMARY
###############################################################################

summary:
  purpose: |
    Tích hợp workflow phân tích sâu (deep analytics) vào hệ thống TILSOFTAI hiện tại,
    cho phép LLM phân tích dữ liệu theo cách tổng quát thông qua:
    - Catalog tools (Schema RAG) thay vì đoán schema
    - Atomic Plan JSON thay vì SQL raw
    - Structured Insight Output (headline + breakdown + notes)
    
  key_changes:
    - "Thêm module TILSOFTAI.Modules.Analytics cho deep analytics"
    - "Tạo catalog_search và catalog_get_dataset tools"  
    - "Enhance Plan Validation với structured error contract"
    - "Thêm Insight Assembly service với output contract ổn định"
    - "Tăng cường Normalization Service với language detection"

  non_breaking_guarantee: |
    Tất cả thay đổi đều ADDITIVE hoặc BACKWARD-COMPATIBLE.
    Không modify signature của existing public APIs.
    Không đổi tên files/tables/SPs hiện có.

###############################################################################
# PATCH EXECUTION ORDER (MANDATORY SEQUENCE)
###############################################################################

execution_order:
  description: "Agent MUST follow this exact sequence. Skip nothing."
  
  phases:
    - phase: "P1_SQL_ARTIFACTS"
      order: 1
      description: "Tạo SQL artifacts cho Analytics module"
      steps:
        - "S1.1: Tạo folder sql/02_modules/analytics/"
        - "S1.2: Tạo 001_tables_analytics.sql"
        - "S1.3: Tạo 002_views_analytics.sql"
        - "S1.4: Tạo 003_sps_app_analytics.sql"
        - "S1.5: Tạo 004_sps_ai_analytics.sql"
        
    - phase: "P2_SQL_SEEDS"
      order: 2
      description: "Tạo seed scripts cho Analytics module"
      steps:
        - "S2.1: Tạo folder sql/99_seed/analytics/"
        - "S2.2: Tạo 001_seed_toolcatalog_analytics.sql"
        - "S2.3: Tạo 002_seed_metadata_dictionary_analytics.sql"
        
    - phase: "P3_DOMAIN_CONTRACTS"
      order: 3
      description: "Thêm domain contracts cho Analytics"
      steps:
        - "S3.1: Tạo Analytics contracts trong TILSOFTAI.Domain"
        - "S3.2: Thêm Configuration options cho Analytics"
        
    - phase: "P4_ORCHESTRATION_ENHANCEMENTS"
      order: 4
      description: "Enhance Orchestration layer"
      steps:
        - "S4.1: Thêm TaskFrameService"
        - "S4.2: Thêm PlanValidationService"
        - "S4.3: Thêm InsightAssemblyService"
        - "S4.4: Enhance NormalizationService"
        
    - phase: "P5_ANALYTICS_MODULE"
      order: 5
      description: "Tạo C# Analytics module"
      steps:
        - "S5.1: Tạo project TILSOFTAI.Modules.Analytics"
        - "S5.2: Implement AnalyticsModule.cs"
        - "S5.3: Implement Tool Handlers"
        
    - phase: "P6_ENABLE_AND_TEST"
      order: 6
      description: "Enable module và setup tests"
      steps:
        - "S6.1: Update appsettings.json"
        - "S6.2: Tạo contract tests"

###############################################################################
# PHASE 1: SQL ARTIFACTS
###############################################################################

phase_1_sql_artifacts:
  folder_structure:
    create:
      - path: "sql/02_modules/analytics"
        type: "directory"

  files:
    #---------------------------------------------------------------------------
    # 001_tables_analytics.sql
    #---------------------------------------------------------------------------
    - path: "sql/02_modules/analytics/001_tables_analytics.sql"
      action: "CREATE"
      description: "Tables cho Analytics workflow state tracking"
      content: |
        /*******************************************************************************
        * TILSOFTAI Analytics Module - Tables
        * Purpose: Analytics workflow state và task frame persistence
        * 
        * IMPORTANT: All tables follow tenant isolation pattern
        *******************************************************************************/
        SET ANSI_NULLS ON;
        SET QUOTED_IDENTIFIER ON;
        GO

        -- TaskFrame persistence (optional, for audit/debugging)
        IF NOT EXISTS (SELECT 1 FROM sys.tables WHERE name = 'AnalyticsTaskFrame' AND schema_id = SCHEMA_ID('dbo'))
        BEGIN
            CREATE TABLE dbo.AnalyticsTaskFrame
            (
                Id                  BIGINT IDENTITY(1,1) NOT NULL,
                TenantId            NVARCHAR(50) NOT NULL,
                ConversationId      NVARCHAR(100) NOT NULL,
                RequestId           NVARCHAR(100) NOT NULL,
                TaskType            NVARCHAR(50) NOT NULL, -- analytics, lookup, explain, mixed
                Entity              NVARCHAR(200) NULL,
                MetricsJson         NVARCHAR(MAX) NULL,
                FiltersJson         NVARCHAR(MAX) NULL,
                BreakdownsJson      NVARCHAR(MAX) NULL,
                TimeRangeHint       NVARCHAR(500) NULL,
                NeedsVisualization  BIT NOT NULL DEFAULT 0,
                Confidence          DECIMAL(5,4) NULL,
                CreatedAtUtc        DATETIME2(3) NOT NULL DEFAULT SYSUTCDATETIME(),
                CONSTRAINT PK_AnalyticsTaskFrame PRIMARY KEY CLUSTERED (Id)
            );
            
            CREATE NONCLUSTERED INDEX IX_AnalyticsTaskFrame_Tenant_Conv 
                ON dbo.AnalyticsTaskFrame (TenantId, ConversationId);
                
            CREATE NONCLUSTERED INDEX IX_AnalyticsTaskFrame_RequestId
                ON dbo.AnalyticsTaskFrame (RequestId);
        END;
        GO

        -- Plan Validation Errors (for retry/learning)
        IF NOT EXISTS (SELECT 1 FROM sys.tables WHERE name = 'AnalyticsPlanValidationError' AND schema_id = SCHEMA_ID('dbo'))
        BEGIN
            CREATE TABLE dbo.AnalyticsPlanValidationError
            (
                Id                  BIGINT IDENTITY(1,1) NOT NULL,
                TenantId            NVARCHAR(50) NOT NULL,
                RequestId           NVARCHAR(100) NOT NULL,
                ErrorCode           NVARCHAR(100) NOT NULL,
                ErrorMessage        NVARCHAR(2000) NULL,
                SuggestionsJson     NVARCHAR(MAX) NULL,
                PlanJson            NVARCHAR(MAX) NULL,
                Retryable           BIT NOT NULL DEFAULT 1,
                RetryCount          INT NOT NULL DEFAULT 0,
                CreatedAtUtc        DATETIME2(3) NOT NULL DEFAULT SYSUTCDATETIME(),
                CONSTRAINT PK_AnalyticsPlanValidationError PRIMARY KEY CLUSTERED (Id)
            );
            
            CREATE NONCLUSTERED INDEX IX_AnalyticsPlanValidationError_Request
                ON dbo.AnalyticsPlanValidationError (RequestId);
        END;
        GO

        -- Insight Cache (semantic cache extension)
        IF NOT EXISTS (SELECT 1 FROM sys.tables WHERE name = 'AnalyticsInsightCache' AND schema_id = SCHEMA_ID('dbo'))
        BEGIN
            CREATE TABLE dbo.AnalyticsInsightCache
            (
                Id                  BIGINT IDENTITY(1,1) NOT NULL,
                TenantId            NVARCHAR(50) NOT NULL,
                QueryHash           NVARCHAR(64) NOT NULL, -- SHA256 of normalized query + plan
                HeadlineText        NVARCHAR(1000) NULL,
                InsightJson         NVARCHAR(MAX) NOT NULL,
                DataFreshnessUtc    DATETIME2(3) NOT NULL,
                ExpiresAtUtc        DATETIME2(3) NOT NULL,
                HitCount            INT NOT NULL DEFAULT 0,
                CreatedAtUtc        DATETIME2(3) NOT NULL DEFAULT SYSUTCDATETIME(),
                CONSTRAINT PK_AnalyticsInsightCache PRIMARY KEY CLUSTERED (Id)
            );
            
            CREATE UNIQUE NONCLUSTERED INDEX UX_AnalyticsInsightCache_TenantQuery
                ON dbo.AnalyticsInsightCache (TenantId, QueryHash);
        END;
        GO

    #---------------------------------------------------------------------------
    # 002_views_analytics.sql
    #---------------------------------------------------------------------------
    - path: "sql/02_modules/analytics/002_views_analytics.sql"
      action: "CREATE"
      description: "Semantic views cho Analytics catalog queries"
      content: |
        /*******************************************************************************
        * TILSOFTAI Analytics Module - Semantic Views
        * Purpose: Flattened views for catalog search and schema RAG
        *******************************************************************************/
        SET ANSI_NULLS ON;
        SET QUOTED_IDENTIFIER ON;
        GO

        -- Dataset catalog view with search-friendly fields
        CREATE OR ALTER VIEW dbo.v_Analytics_DatasetCatalog
        AS
        SELECT
            dc.Id,
            dc.TenantId,
            dc.DatasetKey,
            dc.DisplayName,
            dc.Description,
            dc.BaseObject,
            dc.Grain,
            dc.TimeColumn,
            dc.IsEnabled,
            dc.Tags,
            dc.CreatedAtUtc,
            dc.UpdatedAtUtc,
            -- Computed search fields
            LOWER(dc.DatasetKey + ' ' + ISNULL(dc.DisplayName, '') + ' ' + ISNULL(dc.Description, '') + ' ' + ISNULL(dc.Tags, '')) AS SearchText,
            -- Field count for ranking
            (SELECT COUNT(1) FROM dbo.FieldCatalog fc WHERE fc.DatasetKey = dc.DatasetKey AND fc.IsEnabled = 1) AS EnabledFieldCount
        FROM dbo.DatasetCatalog dc
        WHERE dc.IsEnabled = 1;
        GO

        -- Field catalog view with semantic type info
        CREATE OR ALTER VIEW dbo.v_Analytics_FieldCatalog
        AS
        SELECT
            fc.Id,
            fc.DatasetKey,
            fc.FieldKey,
            fc.PhysicalColumn,
            fc.DisplayName,
            fc.Description,
            fc.DataType,
            fc.SemanticType,
            fc.AllowedAggregations,
            fc.IsFilterable,
            fc.IsGroupable,
            fc.IsSortable,
            fc.IsEnabled,
            fc.SecurityTag,
            -- Computed search fields
            LOWER(fc.FieldKey + ' ' + ISNULL(fc.DisplayName, '') + ' ' + ISNULL(fc.Description, '') + ' ' + ISNULL(fc.SemanticType, '')) AS SearchText
        FROM dbo.FieldCatalog fc
        WHERE fc.IsEnabled = 1;
        GO

        -- Combined catalog search view
        CREATE OR ALTER VIEW dbo.v_Analytics_CatalogSearch
        AS
        SELECT
            'dataset' AS ItemType,
            dc.DatasetKey AS ItemKey,
            dc.DisplayName AS ItemName,
            dc.Description AS ItemDescription,
            dc.SearchText,
            dc.EnabledFieldCount AS Score,
            dc.TenantId,
            dc.Grain,
            NULL AS DatasetKeyRef
        FROM dbo.v_Analytics_DatasetCatalog dc
        UNION ALL
        SELECT
            'field' AS ItemType,
            fc.FieldKey AS ItemKey,
            fc.DisplayName AS ItemName,
            fc.Description AS ItemDescription,
            fc.SearchText,
            CASE 
                WHEN fc.IsFilterable = 1 AND fc.IsGroupable = 1 THEN 10
                WHEN fc.IsFilterable = 1 OR fc.IsGroupable = 1 THEN 5
                ELSE 1
            END AS Score,
            NULL AS TenantId,
            NULL AS Grain,
            fc.DatasetKey AS DatasetKeyRef
        FROM dbo.v_Analytics_FieldCatalog fc;
        GO

    #---------------------------------------------------------------------------
    # 003_sps_app_analytics.sql
    #---------------------------------------------------------------------------
    - path: "sql/02_modules/analytics/003_sps_app_analytics.sql"
      action: "CREATE"
      description: "Internal app_ SPs cho Analytics module"
      content: |
        /*******************************************************************************
        * TILSOFTAI Analytics Module - Internal Stored Procedures (app_*)
        * Purpose: Platform-internal operations, not model-callable
        *******************************************************************************/
        SET ANSI_NULLS ON;
        SET QUOTED_IDENTIFIER ON;
        GO

        -- Save TaskFrame for audit/debugging
        CREATE OR ALTER PROCEDURE dbo.app_analytics_taskframe_save
            @TenantId           NVARCHAR(50),
            @ConversationId     NVARCHAR(100),
            @RequestId          NVARCHAR(100),
            @TaskType           NVARCHAR(50),
            @Entity             NVARCHAR(200) = NULL,
            @MetricsJson        NVARCHAR(MAX) = NULL,
            @FiltersJson        NVARCHAR(MAX) = NULL,
            @BreakdownsJson     NVARCHAR(MAX) = NULL,
            @TimeRangeHint      NVARCHAR(500) = NULL,
            @NeedsVisualization BIT = 0,
            @Confidence         DECIMAL(5,4) = NULL
        AS
        BEGIN
            SET NOCOUNT ON;
            
            IF @TenantId IS NULL OR @TenantId = ''
            BEGIN
                RAISERROR('TenantId is required.', 16, 1);
                RETURN;
            END
            
            INSERT INTO dbo.AnalyticsTaskFrame
            (
                TenantId, ConversationId, RequestId, TaskType, Entity,
                MetricsJson, FiltersJson, BreakdownsJson, TimeRangeHint,
                NeedsVisualization, Confidence
            )
            VALUES
            (
                @TenantId, @ConversationId, @RequestId, @TaskType, @Entity,
                @MetricsJson, @FiltersJson, @BreakdownsJson, @TimeRangeHint,
                @NeedsVisualization, @Confidence
            );
            
            SELECT SCOPE_IDENTITY() AS Id;
        END;
        GO

        -- Save plan validation error
        CREATE OR ALTER PROCEDURE dbo.app_analytics_planvalidationerror_save
            @TenantId       NVARCHAR(50),
            @RequestId      NVARCHAR(100),
            @ErrorCode      NVARCHAR(100),
            @ErrorMessage   NVARCHAR(2000) = NULL,
            @SuggestionsJson NVARCHAR(MAX) = NULL,
            @PlanJson       NVARCHAR(MAX) = NULL,
            @Retryable      BIT = 1,
            @RetryCount     INT = 0
        AS
        BEGIN
            SET NOCOUNT ON;
            
            IF @TenantId IS NULL OR @TenantId = ''
            BEGIN
                RAISERROR('TenantId is required.', 16, 1);
                RETURN;
            END
            
            INSERT INTO dbo.AnalyticsPlanValidationError
            (TenantId, RequestId, ErrorCode, ErrorMessage, SuggestionsJson, PlanJson, Retryable, RetryCount)
            VALUES
            (@TenantId, @RequestId, @ErrorCode, @ErrorMessage, @SuggestionsJson, @PlanJson, @Retryable, @RetryCount);
            
            SELECT SCOPE_IDENTITY() AS Id;
        END;
        GO

        -- Get/set insight cache
        CREATE OR ALTER PROCEDURE dbo.app_analytics_insightcache_get
            @TenantId   NVARCHAR(50),
            @QueryHash  NVARCHAR(64)
        AS
        BEGIN
            SET NOCOUNT ON;
            
            DECLARE @Now DATETIME2(3) = SYSUTCDATETIME();
            
            UPDATE dbo.AnalyticsInsightCache
            SET HitCount = HitCount + 1
            OUTPUT 
                inserted.InsightJson,
                inserted.HeadlineText,
                inserted.DataFreshnessUtc,
                inserted.HitCount
            WHERE TenantId = @TenantId
              AND QueryHash = @QueryHash
              AND ExpiresAtUtc > @Now;
        END;
        GO

        CREATE OR ALTER PROCEDURE dbo.app_analytics_insightcache_set
            @TenantId           NVARCHAR(50),
            @QueryHash          NVARCHAR(64),
            @HeadlineText       NVARCHAR(1000) = NULL,
            @InsightJson        NVARCHAR(MAX),
            @DataFreshnessUtc   DATETIME2(3),
            @TtlSeconds         INT = 300
        AS
        BEGIN
            SET NOCOUNT ON;
            
            DECLARE @ExpiresAtUtc DATETIME2(3) = DATEADD(SECOND, @TtlSeconds, SYSUTCDATETIME());
            
            MERGE dbo.AnalyticsInsightCache AS target
            USING (SELECT @TenantId AS TenantId, @QueryHash AS QueryHash) AS source
            ON target.TenantId = source.TenantId AND target.QueryHash = source.QueryHash
            WHEN MATCHED THEN
                UPDATE SET
                    HeadlineText = @HeadlineText,
                    InsightJson = @InsightJson,
                    DataFreshnessUtc = @DataFreshnessUtc,
                    ExpiresAtUtc = @ExpiresAtUtc,
                    HitCount = 0
            WHEN NOT MATCHED THEN
                INSERT (TenantId, QueryHash, HeadlineText, InsightJson, DataFreshnessUtc, ExpiresAtUtc)
                VALUES (@TenantId, @QueryHash, @HeadlineText, @InsightJson, @DataFreshnessUtc, @ExpiresAtUtc);
        END;
        GO

        -- Purge expired cache entries
        CREATE OR ALTER PROCEDURE dbo.app_analytics_insightcache_purge
            @MaxAgeDays INT = 7
        AS
        BEGIN
            SET NOCOUNT ON;
            
            DELETE FROM dbo.AnalyticsInsightCache
            WHERE ExpiresAtUtc < DATEADD(DAY, -@MaxAgeDays, SYSUTCDATETIME());
            
            SELECT @@ROWCOUNT AS DeletedCount;
        END;
        GO

    #---------------------------------------------------------------------------
    # 004_sps_ai_analytics.sql
    #---------------------------------------------------------------------------
    - path: "sql/02_modules/analytics/004_sps_ai_analytics.sql"
      action: "CREATE"
      description: "Model-callable ai_ SPs cho Analytics (Schema RAG tools)"
      content: |
        /*******************************************************************************
        * TILSOFTAI Analytics Module - Model-Callable Stored Procedures (ai_*)
        * Purpose: Schema RAG tools for LLM to discover datasets/fields
        * 
        * CRITICAL: All ai_* SPs MUST:
        *   1. Accept @TenantId and enforce tenant scope
        *   2. Return JSON envelope (meta + columns + rows)
        *   3. Apply pagination/limit guards
        *******************************************************************************/
        SET ANSI_NULLS ON;
        SET QUOTED_IDENTIFIER ON;
        GO

        -- catalog_search: Search datasets and fields by query
        CREATE OR ALTER PROCEDURE dbo.ai_catalog_search
            @TenantId   NVARCHAR(50),
            @Query      NVARCHAR(500),
            @TopK       INT = 5,
            @Domain     NVARCHAR(50) = 'internal'
        AS
        BEGIN
            SET NOCOUNT ON;
            
            DECLARE @GeneratedAtUtc DATETIME2(3) = SYSUTCDATETIME();
            DECLARE @MaxTopK INT = 20;
            
            -- Validate inputs
            IF @TenantId IS NULL OR @TenantId = ''
            BEGIN
                RAISERROR('TenantId is required.', 16, 1);
                RETURN;
            END
            
            IF @Query IS NULL OR LTRIM(RTRIM(@Query)) = ''
            BEGIN
                RAISERROR('Query is required.', 16, 1);
                RETURN;
            END
            
            IF @TopK <= 0 SET @TopK = 5;
            IF @TopK > @MaxTopK SET @TopK = @MaxTopK;
            
            -- Normalize query for search
            DECLARE @NormalizedQuery NVARCHAR(500) = LOWER(LTRIM(RTRIM(@Query)));
            
            -- Search datasets
            DECLARE @Datasets TABLE (
                DatasetKey NVARCHAR(200),
                DisplayName NVARCHAR(500),
                Description NVARCHAR(2000),
                Grain NVARCHAR(200),
                Score INT
            );
            
            INSERT INTO @Datasets (DatasetKey, DisplayName, Description, Grain, Score)
            SELECT TOP (@TopK)
                DatasetKey,
                ISNULL(DisplayName, DatasetKey),
                Description,
                Grain,
                -- Simple scoring: exact match > contains > partial
                CASE 
                    WHEN LOWER(DatasetKey) = @NormalizedQuery THEN 100
                    WHEN SearchText LIKE '%' + @NormalizedQuery + '%' THEN 50 + EnabledFieldCount
                    ELSE EnabledFieldCount
                END AS Score
            FROM dbo.v_Analytics_DatasetCatalog
            WHERE (TenantId = @TenantId OR TenantId IS NULL)
              AND (
                  LOWER(DatasetKey) = @NormalizedQuery
                  OR SearchText LIKE '%' + @NormalizedQuery + '%'
              )
            ORDER BY Score DESC, DatasetKey;
            
            -- Search fields across matched datasets
            DECLARE @Fields TABLE (
                DatasetKey NVARCHAR(200),
                FieldKey NVARCHAR(200),
                DisplayName NVARCHAR(500),
                DataType NVARCHAR(50),
                SemanticType NVARCHAR(100),
                IsFilterable BIT,
                IsGroupable BIT,
                AllowedAggregations NVARCHAR(500),
                Score INT
            );
            
            INSERT INTO @Fields (DatasetKey, FieldKey, DisplayName, DataType, SemanticType, IsFilterable, IsGroupable, AllowedAggregations, Score)
            SELECT TOP (@TopK * 3)
                fc.DatasetKey,
                fc.FieldKey,
                ISNULL(fc.DisplayName, fc.FieldKey),
                fc.DataType,
                fc.SemanticType,
                fc.IsFilterable,
                fc.IsGroupable,
                fc.AllowedAggregations,
                CASE 
                    WHEN LOWER(fc.FieldKey) = @NormalizedQuery THEN 100
                    WHEN fc.SearchText LIKE '%' + @NormalizedQuery + '%' THEN 50
                    ELSE 10
                END AS Score
            FROM dbo.v_Analytics_FieldCatalog fc
            WHERE fc.DatasetKey IN (SELECT DatasetKey FROM @Datasets)
              OR fc.SearchText LIKE '%' + @NormalizedQuery + '%'
            ORDER BY Score DESC, fc.FieldKey;
            
            -- Generate hints based on search
            DECLARE @Hints TABLE (Hint NVARCHAR(500));
            
            IF NOT EXISTS (SELECT 1 FROM @Datasets)
            BEGIN
                INSERT INTO @Hints (Hint) VALUES ('No datasets found matching query. Try broader search terms.');
            END
            ELSE
            BEGIN
                INSERT INTO @Hints (Hint)
                SELECT TOP 3 'Try dataset: ' + DatasetKey + ' (grain: ' + ISNULL(Grain, 'unknown') + ')'
                FROM @Datasets
                ORDER BY Score DESC;
            END
            
            -- Return JSON envelope
            DECLARE @RowCount INT = (SELECT COUNT(1) FROM @Datasets) + (SELECT COUNT(1) FROM @Fields);
            
            SELECT (
                SELECT
                    meta = (
                        SELECT
                            @TenantId AS tenantId,
                            @GeneratedAtUtc AS generatedAtUtc,
                            @RowCount AS [rowCount],
                            @NormalizedQuery AS searchQuery,
                            @TopK AS topK
                        FOR JSON PATH, WITHOUT_ARRAY_WRAPPER
                    ),
                    datasets = (
                        SELECT DatasetKey, DisplayName, Description, Grain, Score
                        FROM @Datasets
                        ORDER BY Score DESC
                        FOR JSON PATH
                    ),
                    fields = (
                        SELECT DatasetKey, FieldKey, DisplayName, DataType, SemanticType, 
                               IsFilterable, IsGroupable, AllowedAggregations, Score
                        FROM @Fields
                        ORDER BY Score DESC
                        FOR JSON PATH
                    ),
                    hints = (
                        SELECT Hint AS [hint]
                        FROM @Hints
                        FOR JSON PATH
                    )
                FOR JSON PATH, WITHOUT_ARRAY_WRAPPER
            ) AS ResultJson;
        END;
        GO

        -- catalog_get_dataset: Get full schema + metadata for a dataset
        CREATE OR ALTER PROCEDURE dbo.ai_catalog_get_dataset
            @TenantId   NVARCHAR(50),
            @DatasetKey NVARCHAR(200)
        AS
        BEGIN
            SET NOCOUNT ON;
            
            DECLARE @GeneratedAtUtc DATETIME2(3) = SYSUTCDATETIME();
            
            -- Validate inputs
            IF @TenantId IS NULL OR @TenantId = ''
            BEGIN
                RAISERROR('TenantId is required.', 16, 1);
                RETURN;
            END
            
            IF @DatasetKey IS NULL OR LTRIM(RTRIM(@DatasetKey)) = ''
            BEGIN
                RAISERROR('DatasetKey is required.', 16, 1);
                RETURN;
            END
            
            -- Get dataset metadata
            DECLARE @Dataset TABLE (
                DatasetKey NVARCHAR(200),
                DisplayName NVARCHAR(500),
                Description NVARCHAR(2000),
                BaseObject NVARCHAR(500),
                Grain NVARCHAR(200),
                TimeColumn NVARCHAR(200),
                Tags NVARCHAR(1000)
            );
            
            INSERT INTO @Dataset
            SELECT TOP 1
                DatasetKey,
                ISNULL(DisplayName, DatasetKey),
                Description,
                BaseObject,
                Grain,
                TimeColumn,
                Tags
            FROM dbo.v_Analytics_DatasetCatalog
            WHERE DatasetKey = @DatasetKey
              AND (TenantId = @TenantId OR TenantId IS NULL)
            ORDER BY CASE WHEN TenantId = @TenantId THEN 0 ELSE 1 END;
            
            IF NOT EXISTS (SELECT 1 FROM @Dataset)
            BEGIN
                RAISERROR('Dataset not found or access denied.', 16, 1);
                RETURN;
            END
            
            -- Get all enabled fields
            DECLARE @Fields TABLE (
                FieldKey NVARCHAR(200),
                PhysicalColumn NVARCHAR(200),
                DisplayName NVARCHAR(500),
                Description NVARCHAR(2000),
                DataType NVARCHAR(50),
                SemanticType NVARCHAR(100),
                AllowedAggregations NVARCHAR(500),
                IsFilterable BIT,
                IsGroupable BIT,
                IsSortable BIT,
                SecurityTag NVARCHAR(50)
            );
            
            INSERT INTO @Fields
            SELECT
                FieldKey,
                PhysicalColumn,
                ISNULL(DisplayName, FieldKey),
                Description,
                DataType,
                SemanticType,
                AllowedAggregations,
                IsFilterable,
                IsGroupable,
                IsSortable,
                SecurityTag
            FROM dbo.v_Analytics_FieldCatalog
            WHERE DatasetKey = @DatasetKey
            ORDER BY FieldKey;
            
            -- Get join relationships from EntityGraphCatalog (if exists)
            DECLARE @Joins TABLE (
                TargetDatasetKey NVARCHAR(200),
                JoinType NVARCHAR(50),
                SourceFields NVARCHAR(500),
                TargetFields NVARCHAR(500)
            );
            
            IF EXISTS (SELECT 1 FROM sys.tables WHERE name = 'EntityGraphCatalog')
            BEGIN
                INSERT INTO @Joins
                SELECT
                    TargetDatasetKey,
                    JoinType,
                    SourceFields,
                    TargetFields
                FROM dbo.EntityGraphCatalog
                WHERE SourceDatasetKey = @DatasetKey
                  AND IsEnabled = 1;
            END
            
            -- Get example values if available
            DECLARE @Examples TABLE (
                FieldKey NVARCHAR(200),
                ExampleValues NVARCHAR(1000)
            );
            
            -- Return JSON envelope
            DECLARE @RowCount INT = (SELECT COUNT(1) FROM @Fields);
            
            SELECT (
                SELECT
                    meta = (
                        SELECT
                            @TenantId AS tenantId,
                            @GeneratedAtUtc AS generatedAtUtc,
                            @RowCount AS fieldCount
                        FOR JSON PATH, WITHOUT_ARRAY_WRAPPER
                    ),
                    dataset = (
                        SELECT TOP 1 DatasetKey, DisplayName, Description, BaseObject, Grain, TimeColumn, Tags
                        FROM @Dataset
                        FOR JSON PATH, WITHOUT_ARRAY_WRAPPER
                    ),
                    fields = (
                        SELECT FieldKey, PhysicalColumn, DisplayName, Description, DataType,
                               SemanticType, AllowedAggregations, IsFilterable, IsGroupable, IsSortable, SecurityTag
                        FROM @Fields
                        ORDER BY FieldKey
                        FOR JSON PATH
                    ),
                    joins = (
                        SELECT TargetDatasetKey, JoinType, SourceFields, TargetFields
                        FROM @Joins
                        FOR JSON PATH
                    ),
                    examples = (
                        SELECT FieldKey, ExampleValues
                        FROM @Examples
                        FOR JSON PATH
                    )
                FOR JSON PATH, WITHOUT_ARRAY_WRAPPER
            ) AS ResultJson;
        END;
        GO

        -- analytics_validate_plan: Validate atomic plan before execution
        CREATE OR ALTER PROCEDURE dbo.ai_analytics_validate_plan
            @TenantId   NVARCHAR(50),
            @PlanJson   NVARCHAR(MAX)
        AS
        BEGIN
            SET NOCOUNT ON;
            
            DECLARE @GeneratedAtUtc DATETIME2(3) = SYSUTCDATETIME();
            DECLARE @IsValid BIT = 1;
            DECLARE @ErrorCode NVARCHAR(100) = NULL;
            DECLARE @ErrorMessage NVARCHAR(2000) = NULL;
            
            -- Validation limits
            DECLARE @MaxRows INT = 200;
            DECLARE @MaxGroupBy INT = 4;
            DECLARE @MaxMetrics INT = 3;
            DECLARE @MaxJoins INT = 1;
            
            -- Validate inputs
            IF @TenantId IS NULL OR @TenantId = ''
            BEGIN
                RAISERROR('TenantId is required.', 16, 1);
                RETURN;
            END
            
            IF ISJSON(@PlanJson) <> 1
            BEGIN
                SET @IsValid = 0;
                SET @ErrorCode = 'INVALID_JSON';
                SET @ErrorMessage = 'PlanJson must be valid JSON.';
            END
            
            -- Check datasetKey exists
            DECLARE @DatasetKey NVARCHAR(200) = JSON_VALUE(@PlanJson, '$.datasetKey');
            IF @IsValid = 1 AND (@DatasetKey IS NULL OR @DatasetKey = '')
            BEGIN
                SET @IsValid = 0;
                SET @ErrorCode = 'MISSING_DATASET';
                SET @ErrorMessage = 'datasetKey is required.';
            END
            
            -- Validate dataset exists and accessible
            IF @IsValid = 1 AND NOT EXISTS (
                SELECT 1 FROM dbo.DatasetCatalog 
                WHERE DatasetKey = @DatasetKey 
                  AND IsEnabled = 1
                  AND (TenantId = @TenantId OR TenantId IS NULL)
            )
            BEGIN
                SET @IsValid = 0;
                SET @ErrorCode = 'DATASET_NOT_FOUND';
                SET @ErrorMessage = 'Dataset not found or disabled: ' + @DatasetKey;
            END
            
            -- Check limit
            DECLARE @Limit INT = TRY_CONVERT(INT, JSON_VALUE(@PlanJson, '$.limit'));
            IF @IsValid = 1 AND @Limit IS NOT NULL AND @Limit > @MaxRows
            BEGIN
                SET @IsValid = 0;
                SET @ErrorCode = 'LIMIT_EXCEEDED';
                SET @ErrorMessage = 'Limit exceeds maximum allowed (' + CAST(@MaxRows AS NVARCHAR(10)) + ').';
            END
            
            -- Check groupBy count
            DECLARE @GroupByCount INT = (SELECT COUNT(1) FROM OPENJSON(@PlanJson, '$.groupBy'));
            IF @IsValid = 1 AND @GroupByCount > @MaxGroupBy
            BEGIN
                SET @IsValid = 0;
                SET @ErrorCode = 'GROUPBY_EXCEEDED';
                SET @ErrorMessage = 'GroupBy count exceeds maximum allowed (' + CAST(@MaxGroupBy AS NVARCHAR(10)) + ').';
            END
            
            -- Check metrics count
            DECLARE @MetricsCount INT = (SELECT COUNT(1) FROM OPENJSON(@PlanJson, '$.metrics'));
            IF @IsValid = 1 AND @MetricsCount > @MaxMetrics
            BEGIN
                SET @IsValid = 0;
                SET @ErrorCode = 'METRICS_EXCEEDED';
                SET @ErrorMessage = 'Metrics count exceeds maximum allowed (' + CAST(@MaxMetrics AS NVARCHAR(10)) + ').';
            END
            
            -- Validate field existence
            DECLARE @InvalidFields TABLE (FieldKey NVARCHAR(200));
            
            IF @IsValid = 1
            BEGIN
                -- Check select fields
                INSERT INTO @InvalidFields (FieldKey)
                SELECT value
                FROM OPENJSON(@PlanJson, '$.select')
                WHERE value NOT IN (
                    SELECT FieldKey FROM dbo.FieldCatalog WHERE DatasetKey = @DatasetKey AND IsEnabled = 1
                );
                
                -- Check where fields
                INSERT INTO @InvalidFields (FieldKey)
                SELECT JSON_VALUE(value, '$.field')
                FROM OPENJSON(@PlanJson, '$.where')
                WHERE JSON_VALUE(value, '$.field') NOT IN (
                    SELECT FieldKey FROM dbo.FieldCatalog WHERE DatasetKey = @DatasetKey AND IsEnabled = 1
                );
                
                -- Check groupBy fields
                INSERT INTO @InvalidFields (FieldKey)
                SELECT value
                FROM OPENJSON(@PlanJson, '$.groupBy')
                WHERE value NOT IN (
                    SELECT FieldKey FROM dbo.FieldCatalog WHERE DatasetKey = @DatasetKey AND IsEnabled = 1
                );
                
                IF EXISTS (SELECT 1 FROM @InvalidFields)
                BEGIN
                    SET @IsValid = 0;
                    SET @ErrorCode = 'UNKNOWN_FIELD';
                    SELECT @ErrorMessage = 'Unknown fields: ' + STRING_AGG(FieldKey, ', ')
                    FROM @InvalidFields;
                END
            END
            
            -- Generate suggestions for errors
            DECLARE @Suggestions TABLE (Suggestion NVARCHAR(500));
            
            IF @IsValid = 0
            BEGIN
                IF @ErrorCode = 'UNKNOWN_FIELD'
                BEGIN
                    -- Suggest similar fields (fuzzy match)
                    INSERT INTO @Suggestions (Suggestion)
                    SELECT TOP 5 'Did you mean: ' + fc.FieldKey
                    FROM @InvalidFields inv
                    CROSS APPLY (
                        SELECT FieldKey
                        FROM dbo.FieldCatalog
                        WHERE DatasetKey = @DatasetKey AND IsEnabled = 1
                          AND SOUNDEX(FieldKey) = SOUNDEX(inv.FieldKey)
                    ) fc;
                END
                
                IF @ErrorCode = 'LIMIT_EXCEEDED'
                BEGIN
                    INSERT INTO @Suggestions (Suggestion)
                    VALUES ('Use limit <= ' + CAST(@MaxRows AS NVARCHAR(10)));
                END
            END
            
            -- Return validation result
            SELECT (
                SELECT
                    meta = (
                        SELECT
                            @TenantId AS tenantId,
                            @GeneratedAtUtc AS generatedAtUtc,
                            @DatasetKey AS datasetKey
                        FOR JSON PATH, WITHOUT_ARRAY_WRAPPER
                    ),
                    validation = (
                        SELECT
                            @IsValid AS isValid,
                            @ErrorCode AS errorCode,
                            @ErrorMessage AS errorMessage,
                            CASE WHEN @IsValid = 0 THEN 1 ELSE 0 END AS retryable
                        FOR JSON PATH, WITHOUT_ARRAY_WRAPPER
                    ),
                    suggestions = (
                        SELECT Suggestion AS [suggestion]
                        FROM @Suggestions
                        FOR JSON PATH
                    )
                FOR JSON PATH, WITHOUT_ARRAY_WRAPPER
            ) AS ResultJson;
        END;
        GO

###############################################################################
# PHASE 2: SQL SEEDS
###############################################################################

phase_2_sql_seeds:
  folder_structure:
    create:
      - path: "sql/99_seed/analytics"
        type: "directory"

  files:
    #---------------------------------------------------------------------------
    # 001_seed_toolcatalog_analytics.sql
    #---------------------------------------------------------------------------
    - path: "sql/99_seed/analytics/001_seed_toolcatalog_analytics.sql"
      action: "CREATE"
      description: "Seed ToolCatalog entries cho Analytics tools"
      content: |
        /*******************************************************************************
        * TILSOFTAI Analytics Module - Tool Catalog Seeds
        * Purpose: Register analytics tools for LLM
        *******************************************************************************/
        SET ANSI_NULLS ON;
        SET QUOTED_IDENTIFIER ON;
        GO

        -- catalog_search tool
        IF NOT EXISTS (SELECT 1 FROM dbo.ToolCatalog WHERE ToolName = 'catalog_search')
        BEGIN
            INSERT INTO dbo.ToolCatalog
            (ToolName, SpName, IsEnabled, RequiredRoles, JsonSchema, Instruction, Description)
            VALUES
            (
                'catalog_search',
                'ai_catalog_search',
                1,
                NULL,
                '{
                    "type": "object",
                    "required": ["query"],
                    "additionalProperties": false,
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": "Search terms to find relevant datasets and fields (e.g., ''model count season'')",
                            "minLength": 2,
                            "maxLength": 500
                        },
                        "topK": {
                            "type": "integer",
                            "description": "Maximum number of results per category (datasets/fields)",
                            "minimum": 1,
                            "maximum": 20,
                            "default": 5
                        },
                        "domain": {
                            "type": "string",
                            "description": "Search domain scope",
                            "enum": ["internal", "all"],
                            "default": "internal"
                        }
                    }
                }',
                'Use this tool FIRST when you need to find datasets or fields for analytics queries. 
                
        WHEN TO CALL:
        - User asks analytics questions (count, sum, breakdown, top N, trends)
        - You do not know which dataset/fields to use
        - You need to discover available metrics or dimensions

        HOW TO USE:
        1. Extract key entities from user question (e.g., "model", "order", "season")
        2. Compose search query from entity + metric hints
        3. Review results: datasets[] shows available data sources, fields[] shows queryable columns
        4. Use hints[] for guidance on best matches

        FOLLOW-UP ACTIONS:
        - If good dataset found: call catalog_get_dataset to get full schema
        - If no matches: try broader terms or ask user for clarification
        - NEVER guess schema without calling this tool first',
                'Search for datasets and fields in the data catalog by keywords. Returns matching datasets, fields, and usage hints.'
            );
        END;
        GO

        -- catalog_search translations
        IF NOT EXISTS (SELECT 1 FROM dbo.ToolCatalogTranslation WHERE ToolName = 'catalog_search' AND Language = 'en')
        BEGIN
            INSERT INTO dbo.ToolCatalogTranslation (ToolName, Language, Instruction, Description)
            VALUES
            (
                'catalog_search',
                'en',
                'Use this tool FIRST when you need to find datasets or fields for analytics queries. Extract key entities from user question, compose search query, and review results before proceeding.',
                'Search for datasets and fields in the data catalog by keywords.'
            );
        END;
        GO

        IF NOT EXISTS (SELECT 1 FROM dbo.ToolCatalogTranslation WHERE ToolName = 'catalog_search' AND Language = 'vi')
        BEGIN
            INSERT INTO dbo.ToolCatalogTranslation (ToolName, Language, Instruction, Description)
            VALUES
            (
                'catalog_search',
                'vi',
                'Dùng tool này TRƯỚC TIÊN khi cần tìm dataset hoặc field cho câu hỏi phân tích. Trích xuất entity chính từ câu hỏi, tạo query tìm kiếm, và xem kết quả trước khi tiếp tục.',
                'Tìm kiếm dataset và field trong catalog theo từ khóa.'
            );
        END;
        GO

        -- catalog_get_dataset tool
        IF NOT EXISTS (SELECT 1 FROM dbo.ToolCatalog WHERE ToolName = 'catalog_get_dataset')
        BEGIN
            INSERT INTO dbo.ToolCatalog
            (ToolName, SpName, IsEnabled, RequiredRoles, JsonSchema, Instruction, Description)
            VALUES
            (
                'catalog_get_dataset',
                'ai_catalog_get_dataset',
                1,
                NULL,
                '{
                    "type": "object",
                    "required": ["datasetKey"],
                    "additionalProperties": false,
                    "properties": {
                        "datasetKey": {
                            "type": "string",
                            "description": "The exact datasetKey from catalog_search results",
                            "minLength": 1,
                            "maxLength": 200
                        }
                    }
                }',
                'Use this tool to get FULL SCHEMA of a dataset after finding it via catalog_search.

        WHEN TO CALL:
        - After catalog_search returned matching dataset(s)
        - Before creating an atomic_execute_plan
        - When you need to know exact field names, types, and allowed aggregations

        WHAT YOU GET:
        - dataset: grain (what each row represents), timeColumn (for time filters)
        - fields[]: all queryable fields with their properties
          - fieldKey: use this in atomic plan
          - dataType: string/int/decimal/datetime
          - semanticType: dimension/measure/identifier
          - allowedAggregations: which ops are valid (count, sum, avg, etc.)
          - isFilterable/isGroupable: can be used in where/groupBy
          - securityTag: PII fields may be masked
        - joins[]: available relationships to other datasets (max 1 hop)

        FOLLOW-UP ACTIONS:
        - Use schema to build atomic_execute_plan
        - Only use fields that exist in this schema
        - Only use aggregations allowed for each field',
                'Get full schema and metadata for a specific dataset including all fields, types, and allowed operations.'
            );
        END;
        GO

        -- catalog_get_dataset translations
        IF NOT EXISTS (SELECT 1 FROM dbo.ToolCatalogTranslation WHERE ToolName = 'catalog_get_dataset' AND Language = 'en')
        BEGIN
            INSERT INTO dbo.ToolCatalogTranslation (ToolName, Language, Instruction, Description)
            VALUES
            (
                'catalog_get_dataset',
                'en',
                'Get full schema of a dataset after finding it via catalog_search. Use schema to build atomic plan with correct field names and allowed aggregations.',
                'Get full schema and metadata for a specific dataset.'
            );
        END;
        GO

        IF NOT EXISTS (SELECT 1 FROM dbo.ToolCatalogTranslation WHERE ToolName = 'catalog_get_dataset' AND Language = 'vi')
        BEGIN
            INSERT INTO dbo.ToolCatalogTranslation (ToolName, Language, Instruction, Description)
            VALUES
            (
                'catalog_get_dataset',
                'vi',
                'Lấy schema đầy đủ của dataset sau khi tìm qua catalog_search. Dùng schema để tạo atomic plan với đúng tên field và aggregation cho phép.',
                'Lấy schema và metadata đầy đủ cho một dataset cụ thể.'
            );
        END;
        GO

        -- analytics_validate_plan tool
        IF NOT EXISTS (SELECT 1 FROM dbo.ToolCatalog WHERE ToolName = 'analytics_validate_plan')
        BEGIN
            INSERT INTO dbo.ToolCatalog
            (ToolName, SpName, IsEnabled, RequiredRoles, JsonSchema, Instruction, Description)
            VALUES
            (
                'analytics_validate_plan',
                'ai_analytics_validate_plan',
                1,
                NULL,
                '{
                    "type": "object",
                    "required": ["planJson"],
                    "additionalProperties": false,
                    "properties": {
                        "planJson": {
                            "type": "object",
                            "description": "The atomic plan to validate before execution"
                        }
                    }
                }',
                'Use this tool to validate an atomic plan BEFORE executing it.

        WHEN TO CALL:
        - After constructing atomic plan from schema
        - Before calling atomic_execute_plan
        - When plan is complex (multiple filters, groupBy, metrics)

        VALIDATION CHECKS:
        - datasetKey exists and is accessible
        - All fields exist in dataset
        - Aggregation ops are allowed for each field
        - Limits are within bounds (maxRows=200, maxGroupBy=4, maxMetrics=3)
        - Security tags are respected

        IF VALIDATION FAILS:
        - Check validation.errorCode and errorMessage
        - Review suggestions[] for fixes
        - If retryable=true, fix the plan and validate again (max 2 retries)
        - If retryable=false, inform user of limitation',
                'Validate an atomic plan before execution. Returns validation result with error details and suggestions.'
            );
        END;
        GO

    #---------------------------------------------------------------------------
    # 002_seed_metadata_dictionary_analytics.sql
    #---------------------------------------------------------------------------
    - path: "sql/99_seed/analytics/002_seed_metadata_dictionary_analytics.sql"
      action: "CREATE"
      description: "Seed MetadataDictionary entries cho Analytics output"
      content: |
        /*******************************************************************************
        * TILSOFTAI Analytics Module - Metadata Dictionary Seeds
        * Purpose: Localized labels for analytics output fields
        *******************************************************************************/
        SET ANSI_NULLS ON;
        SET QUOTED_IDENTIFIER ON;
        GO

        -- Insight output labels
        MERGE dbo.MetadataDictionary AS target
        USING (VALUES
            (NULL, 'analytics.headline', 'en', 'Headline', 'Summary headline for the insight'),
            (NULL, 'analytics.headline', 'vi', 'Tiêu đề', 'Tiêu đề tóm tắt insight'),
            (NULL, 'analytics.breakdown', 'en', 'Breakdown', 'Detailed breakdown by category'),
            (NULL, 'analytics.breakdown', 'vi', 'Phân tích chi tiết', 'Phân tích chi tiết theo danh mục'),
            (NULL, 'analytics.total', 'en', 'Total', 'Grand total'),
            (NULL, 'analytics.total', 'vi', 'Tổng', 'Tổng số'),
            (NULL, 'analytics.notes', 'en', 'Notes', 'Additional notes and warnings'),
            (NULL, 'analytics.notes', 'vi', 'Ghi chú', 'Ghi chú và cảnh báo bổ sung'),
            (NULL, 'analytics.filter', 'en', 'Filter', 'Applied filter'),
            (NULL, 'analytics.filter', 'vi', 'Bộ lọc', 'Bộ lọc đã áp dụng'),
            (NULL, 'analytics.limit', 'en', 'Limit', 'Result limit applied'),
            (NULL, 'analytics.limit', 'vi', 'Giới hạn', 'Giới hạn kết quả đã áp dụng'),
            (NULL, 'analytics.freshness', 'en', 'Data freshness', 'When data was last updated'),
            (NULL, 'analytics.freshness', 'vi', 'Độ tươi dữ liệu', 'Thời điểm dữ liệu được cập nhật'),
            (NULL, 'analytics.truncated', 'en', 'Results truncated', 'Not all results shown'),
            (NULL, 'analytics.truncated', 'vi', 'Kết quả bị cắt', 'Không hiển thị hết kết quả'),
            (NULL, 'analytics.season', 'en', 'Season', 'Business season'),
            (NULL, 'analytics.season', 'vi', 'Mùa', 'Mùa kinh doanh'),
            (NULL, 'analytics.count', 'en', 'Count', 'Number of items'),
            (NULL, 'analytics.count', 'vi', 'Số lượng', 'Số mục')
        ) AS source (TenantId, [Key], Language, DisplayName, Description)
        ON target.TenantId IS NOT DISTINCT FROM source.TenantId 
           AND target.[Key] = source.[Key] 
           AND target.Language = source.Language
        WHEN NOT MATCHED THEN
            INSERT (TenantId, [Key], Language, DisplayName, Description)
            VALUES (source.TenantId, source.[Key], source.Language, source.DisplayName, source.Description);
        GO

###############################################################################
# PHASE 3: DOMAIN CONTRACTS
###############################################################################

phase_3_domain_contracts:
  files:
    #---------------------------------------------------------------------------
    # Analytics Configuration Options
    #---------------------------------------------------------------------------
    - path: "src/TILSOFTAI.Domain/Configuration/AnalyticsOptions.cs"
      action: "CREATE"
      description: "Configuration options cho Analytics workflow"
      content: |
        namespace TILSOFTAI.Domain.Configuration;

        /// <summary>
        /// Configuration options for the Analytics workflow.
        /// </summary>
        public sealed class AnalyticsOptions
        {
            /// <summary>
            /// Maximum number of rows returned by analytics queries.
            /// </summary>
            public int MaxRows { get; set; } = 200;

            /// <summary>
            /// Maximum number of groupBy fields allowed.
            /// </summary>
            public int MaxGroupBy { get; set; } = 4;

            /// <summary>
            /// Maximum number of metrics allowed per query.
            /// </summary>
            public int MaxMetrics { get; set; } = 3;

            /// <summary>
            /// Maximum number of joins allowed (start with 1 hop).
            /// </summary>
            public int MaxJoins { get; set; } = 1;

            /// <summary>
            /// Maximum time window in days for time-range queries.
            /// </summary>
            public int MaxTimeWindowDays { get; set; } = 366;

            /// <summary>
            /// Allowed metric operations.
            /// </summary>
            public string[] AllowedMetricOps { get; set; } = 
                { "count", "countDistinct", "sum", "avg", "min", "max" };

            /// <summary>
            /// Maximum plan validation retries.
            /// </summary>
            public int MaxPlanRetries { get; set; } = 2;

            /// <summary>
            /// Enable task frame persistence for audit.
            /// </summary>
            public bool EnableTaskFramePersistence { get; set; } = true;

            /// <summary>
            /// Enable insight caching.
            /// </summary>
            public bool EnableInsightCache { get; set; } = true;

            /// <summary>
            /// Default insight cache TTL in seconds.
            /// </summary>
            public int InsightCacheTtlSeconds { get; set; } = 300;
        }

    #---------------------------------------------------------------------------
    # TaskFrame Contract
    #---------------------------------------------------------------------------
    - path: "src/TILSOFTAI.Domain/Analytics/TaskFrame.cs"
      action: "CREATE"
      description: "TaskFrame contract cho intent framing"
      content: |
        using System.Text.Json.Serialization;

        namespace TILSOFTAI.Domain.Analytics;

        /// <summary>
        /// Represents the structured task frame derived from user intent.
        /// </summary>
        public sealed class TaskFrame
        {
            [JsonPropertyName("taskType")]
            public TaskType TaskType { get; set; } = TaskType.Analytics;

            [JsonPropertyName("entity")]
            public string? Entity { get; set; }

            [JsonPropertyName("metrics")]
            public List<MetricSpec> Metrics { get; set; } = new();

            [JsonPropertyName("filters")]
            public List<FilterSpec> Filters { get; set; } = new();

            [JsonPropertyName("breakdowns")]
            public List<string> Breakdowns { get; set; } = new();

            [JsonPropertyName("timeRangeHint")]
            public string? TimeRangeHint { get; set; }

            [JsonPropertyName("needsVisualization")]
            public bool NeedsVisualization { get; set; }

            [JsonPropertyName("confidence")]
            public decimal Confidence { get; set; }
        }

        [JsonConverter(typeof(JsonStringEnumConverter))]
        public enum TaskType
        {
            Analytics,
            Lookup,
            Explain,
            Mixed
        }

        public sealed class MetricSpec
        {
            [JsonPropertyName("op")]
            public string Op { get; set; } = "count";

            [JsonPropertyName("fieldHint")]
            public string? FieldHint { get; set; }

            [JsonPropertyName("as")]
            public string? As { get; set; }
        }

        public sealed class FilterSpec
        {
            [JsonPropertyName("fieldHint")]
            public string? FieldHint { get; set; }

            [JsonPropertyName("op")]
            public string Op { get; set; } = "eq";

            [JsonPropertyName("value")]
            public object? Value { get; set; }
        }

    #---------------------------------------------------------------------------
    # InsightOutput Contract
    #---------------------------------------------------------------------------
    - path: "src/TILSOFTAI.Domain/Analytics/InsightOutput.cs"
      action: "CREATE"
      description: "InsightOutput contract cho structured response"
      content: |
        using System.Text.Json.Serialization;

        namespace TILSOFTAI.Domain.Analytics;

        /// <summary>
        /// Represents the structured insight output with stable format.
        /// </summary>
        public sealed class InsightOutput
        {
            [JsonPropertyName("headline")]
            public InsightHeadline Headline { get; set; } = new();

            [JsonPropertyName("tables")]
            public List<InsightTable> Tables { get; set; } = new();

            [JsonPropertyName("notes")]
            public List<string> Notes { get; set; } = new();

            [JsonPropertyName("warnings")]
            public List<string> Warnings { get; set; } = new();

            [JsonPropertyName("freshness")]
            public DataFreshness? Freshness { get; set; }
        }

        public sealed class InsightHeadline
        {
            [JsonPropertyName("text")]
            public string Text { get; set; } = string.Empty;

            [JsonPropertyName("language")]
            public string Language { get; set; } = "en";
        }

        public sealed class InsightTable
        {
            [JsonPropertyName("title")]
            public string Title { get; set; } = string.Empty;

            [JsonPropertyName("columns")]
            public List<string> Columns { get; set; } = new();

            [JsonPropertyName("rows")]
            public List<List<object?>> Rows { get; set; } = new();

            [JsonPropertyName("topN")]
            public int? TopN { get; set; }
        }

        public sealed class DataFreshness
        {
            [JsonPropertyName("asOfUtc")]
            public DateTime AsOfUtc { get; set; }

            [JsonPropertyName("source")]
            public string Source { get; set; } = "SQL";
        }

    #---------------------------------------------------------------------------
    # PlanValidationResult Contract
    #---------------------------------------------------------------------------
    - path: "src/TILSOFTAI.Domain/Analytics/PlanValidationResult.cs"
      action: "CREATE"
      description: "PlanValidationResult contract với structured errors"
      content: |
        using System.Text.Json.Serialization;

        namespace TILSOFTAI.Domain.Analytics;

        /// <summary>
        /// Result of plan validation with structured error contract.
        /// </summary>
        public sealed class PlanValidationResult
        {
            [JsonPropertyName("isValid")]
            public bool IsValid { get; set; }

            [JsonPropertyName("errorCode")]
            public string? ErrorCode { get; set; }

            [JsonPropertyName("errorMessage")]
            public string? ErrorMessage { get; set; }

            [JsonPropertyName("suggestions")]
            public List<string> Suggestions { get; set; } = new();

            [JsonPropertyName("retryable")]
            public bool Retryable { get; set; } = true;

            public static PlanValidationResult Success() => new() { IsValid = true };

            public static PlanValidationResult Fail(
                string errorCode, 
                string message, 
                bool retryable = true,
                params string[] suggestions) => new()
            {
                IsValid = false,
                ErrorCode = errorCode,
                ErrorMessage = message,
                Retryable = retryable,
                Suggestions = suggestions.ToList()
            };
        }

        /// <summary>
        /// Error codes for plan validation.
        /// </summary>
        public static class PlanValidationErrorCodes
        {
            public const string InvalidJson = "INVALID_JSON";
            public const string MissingDataset = "MISSING_DATASET";
            public const string DatasetNotFound = "DATASET_NOT_FOUND";
            public const string UnknownField = "UNKNOWN_FIELD";
            public const string InvalidOp = "INVALID_OP";
            public const string LimitExceeded = "LIMIT_EXCEEDED";
            public const string GroupByExceeded = "GROUPBY_EXCEEDED";
            public const string MetricsExceeded = "METRICS_EXCEEDED";
            public const string JoinsExceeded = "JOINS_EXCEEDED";
            public const string SecurityViolation = "SECURITY_VIOLATION";
            public const string TimeWindowExceeded = "TIME_WINDOW_EXCEEDED";
        }

###############################################################################
# PHASE 4: ORCHESTRATION ENHANCEMENTS
###############################################################################

phase_4_orchestration_enhancements:
  files:
    #---------------------------------------------------------------------------
    # Enhanced NormalizationMeta
    #---------------------------------------------------------------------------
    - path: "src/TILSOFTAI.Orchestration/Normalization/NormalizationMeta.cs"
      action: "CREATE"
      description: "Metadata từ quá trình normalization"
      content: |
        namespace TILSOFTAI.Orchestration.Normalization;

        /// <summary>
        /// Metadata captured during input normalization.
        /// </summary>
        public sealed class NormalizationMeta
        {
            /// <summary>
            /// Original raw input before normalization.
            /// </summary>
            public string RawInput { get; set; } = string.Empty;

            /// <summary>
            /// Normalized output.
            /// </summary>
            public string NormalizedInput { get; set; } = string.Empty;

            /// <summary>
            /// Detected language hint.
            /// </summary>
            public string LanguageHint { get; set; } = "en";

            /// <summary>
            /// Applied transformations.
            /// </summary>
            public List<string> Transformations { get; set; } = new();

            /// <summary>
            /// Season normalizations applied (e.g., "25/26 -> 2025/2026").
            /// </summary>
            public Dictionary<string, string> SeasonNormalizations { get; set; } = new();

            /// <summary>
            /// Whether whitespace was normalized.
            /// </summary>
            public bool WhitespaceNormalized { get; set; }
        }

    #---------------------------------------------------------------------------
    # InsightAssemblyService Interface
    #---------------------------------------------------------------------------
    - path: "src/TILSOFTAI.Orchestration/Analytics/IInsightAssemblyService.cs"
      action: "CREATE"
      description: "Interface cho InsightAssembly"
      content: |
        using TILSOFTAI.Domain.Analytics;
        using TILSOFTAI.Domain.ExecutionContext;

        namespace TILSOFTAI.Orchestration.Analytics;

        /// <summary>
        /// Service to assemble query results into structured insight output.
        /// </summary>
        public interface IInsightAssemblyService
        {
            /// <summary>
            /// Assemble insight from query results.
            /// </summary>
            Task<InsightOutput> AssembleAsync(
                TaskFrame taskFrame,
                IReadOnlyList<QueryResultSet> queryResults,
                TilsoftExecutionContext context,
                CancellationToken ct);
        }

        /// <summary>
        /// Represents a query result set with metadata.
        /// </summary>
        public sealed class QueryResultSet
        {
            public string Label { get; set; } = string.Empty;
            public QueryResultType Type { get; set; }
            public List<string> Columns { get; set; } = new();
            public List<List<object?>> Rows { get; set; } = new();
            public int RowCount { get; set; }
            public bool Truncated { get; set; }
            public DateTime GeneratedAtUtc { get; set; }
            public List<string> Warnings { get; set; } = new();
        }

        public enum QueryResultType
        {
            Total,
            Breakdown,
            Drilldown
        }

    #---------------------------------------------------------------------------
    # InsightAssemblyService Implementation
    #---------------------------------------------------------------------------
    - path: "src/TILSOFTAI.Orchestration/Analytics/InsightAssemblyService.cs"
      action: "CREATE"
      description: "Implementation của InsightAssemblyService"
      content: |
        using System.Globalization;
        using Microsoft.Extensions.Logging;
        using Microsoft.Extensions.Options;
        using TILSOFTAI.Domain.Analytics;
        using TILSOFTAI.Domain.Configuration;
        using TILSOFTAI.Domain.ExecutionContext;

        namespace TILSOFTAI.Orchestration.Analytics;

        /// <summary>
        /// Assembles query results into structured insight output.
        /// </summary>
        public sealed class InsightAssemblyService : IInsightAssemblyService
        {
            private readonly AnalyticsOptions _options;
            private readonly ILogger<InsightAssemblyService> _logger;

            public InsightAssemblyService(
                IOptions<AnalyticsOptions> options,
                ILogger<InsightAssemblyService> logger)
            {
                _options = options?.Value ?? new AnalyticsOptions();
                _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            }

            public Task<InsightOutput> AssembleAsync(
                TaskFrame taskFrame,
                IReadOnlyList<QueryResultSet> queryResults,
                TilsoftExecutionContext context,
                CancellationToken ct)
            {
                ArgumentNullException.ThrowIfNull(taskFrame);
                ArgumentNullException.ThrowIfNull(queryResults);
                ArgumentNullException.ThrowIfNull(context);

                var insight = new InsightOutput
                {
                    Headline = BuildHeadline(taskFrame, queryResults, context.Language),
                    Tables = BuildTables(queryResults, context.Language),
                    Notes = BuildNotes(taskFrame, queryResults, context.Language),
                    Warnings = CollectWarnings(queryResults),
                    Freshness = GetFreshness(queryResults)
                };

                _logger.LogInformation(
                    "InsightAssembled | Headline: {Headline} | Tables: {TableCount} | Notes: {NoteCount}",
                    insight.Headline.Text, insight.Tables.Count, insight.Notes.Count);

                return Task.FromResult(insight);
            }

            private static InsightHeadline BuildHeadline(
                TaskFrame taskFrame, 
                IReadOnlyList<QueryResultSet> results,
                string language)
            {
                var totalResult = results.FirstOrDefault(r => r.Type == QueryResultType.Total);
                
                string headlineText;
                if (totalResult?.Rows.Count > 0 && totalResult.Rows[0].Count > 0)
                {
                    var value = totalResult.Rows[0][0];
                    var formattedValue = FormatNumber(value);
                    
                    var entity = taskFrame.Entity ?? "items";
                    var filterContext = BuildFilterContext(taskFrame, language);
                    
                    headlineText = language == "vi"
                        ? $"{filterContext} có {formattedValue} {entity}"
                        : $"{filterContext} has {formattedValue} {entity}";
                }
                else
                {
                    // Fallback: sum from breakdown if no total
                    var breakdown = results.FirstOrDefault(r => r.Type == QueryResultType.Breakdown);
                    if (breakdown?.Rows.Count > 0)
                    {
                        var sum = breakdown.Rows
                            .Where(r => r.Count > 1)
                            .Sum(r => Convert.ToDecimal(r[^1] ?? 0));
                        
                        var entity = taskFrame.Entity ?? "items";
                        headlineText = language == "vi"
                            ? $"Tổng: {FormatNumber(sum)} {entity}"
                            : $"Total: {FormatNumber(sum)} {entity}";
                    }
                    else
                    {
                        headlineText = language == "vi" 
                            ? "Không có dữ liệu" 
                            : "No data available";
                    }
                }

                return new InsightHeadline { Text = headlineText, Language = language };
            }

            private static string BuildFilterContext(TaskFrame taskFrame, string language)
            {
                if (taskFrame.Filters.Count == 0)
                    return language == "vi" ? "Tổng cộng" : "Overall";

                var seasonFilter = taskFrame.Filters
                    .FirstOrDefault(f => f.FieldHint?.Contains("season", StringComparison.OrdinalIgnoreCase) == true);
                
                if (seasonFilter?.Value != null)
                {
                    return language == "vi" 
                        ? $"Mùa {seasonFilter.Value}" 
                        : $"Season {seasonFilter.Value}";
                }

                return language == "vi" ? "Theo bộ lọc" : "Filtered";
            }

            private static List<InsightTable> BuildTables(
                IReadOnlyList<QueryResultSet> results, 
                string language)
            {
                return results
                    .Where(r => r.Type == QueryResultType.Breakdown && r.Rows.Count > 0)
                    .Select(r => new InsightTable
                    {
                        Title = r.Label,
                        Columns = r.Columns,
                        Rows = r.Rows,
                        TopN = r.Rows.Count
                    })
                    .ToList();
            }

            private static List<string> BuildNotes(
                TaskFrame taskFrame,
                IReadOnlyList<QueryResultSet> results,
                string language)
            {
                var notes = new List<string>();

                // Filter notes
                foreach (var filter in taskFrame.Filters)
                {
                    var filterText = language == "vi"
                        ? $"Bộ lọc: {filter.FieldHint} {filter.Op} {filter.Value}"
                        : $"Filter: {filter.FieldHint} {filter.Op} {filter.Value}";
                    notes.Add(filterText);
                }

                // Limit notes
                foreach (var result in results.Where(r => r.Type == QueryResultType.Breakdown))
                {
                    if (result.Truncated)
                    {
                        var limitText = language == "vi"
                            ? $"Giới hạn: Top {result.RowCount} cho {result.Label}"
                            : $"Limit: Top {result.RowCount} for {result.Label}";
                        notes.Add(limitText);
                    }
                }

                return notes;
            }

            private static List<string> CollectWarnings(IReadOnlyList<QueryResultSet> results)
            {
                return results
                    .SelectMany(r => r.Warnings)
                    .Distinct()
                    .ToList();
            }

            private static DataFreshness? GetFreshness(IReadOnlyList<QueryResultSet> results)
            {
                var latestResult = results
                    .OrderByDescending(r => r.GeneratedAtUtc)
                    .FirstOrDefault();

                return latestResult != null
                    ? new DataFreshness
                    {
                        AsOfUtc = latestResult.GeneratedAtUtc,
                        Source = "SQL"
                    }
                    : null;
            }

            private static string FormatNumber(object? value)
            {
                return value switch
                {
                    null => "0",
                    int i => i.ToString("N0", CultureInfo.InvariantCulture),
                    long l => l.ToString("N0", CultureInfo.InvariantCulture),
                    decimal d => d.ToString("N0", CultureInfo.InvariantCulture),
                    double db => db.ToString("N0", CultureInfo.InvariantCulture),
                    _ => value.ToString() ?? "0"
                };
            }
        }

###############################################################################
# PHASE 5: ANALYTICS MODULE
###############################################################################

phase_5_analytics_module:
  project:
    path: "src/TILSOFTAI.Modules.Analytics/TILSOFTAI.Modules.Analytics.csproj"
    action: "CREATE"
    content: |
      <Project Sdk="Microsoft.NET.Sdk">
        <PropertyGroup>
          <TargetFramework>net10.0</TargetFramework>
          <ImplicitUsings>enable</ImplicitUsings>
          <Nullable>enable</Nullable>
          <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
        </PropertyGroup>
        <ItemGroup>
          <ProjectReference Include="..\TILSOFTAI.Domain\TILSOFTAI.Domain.csproj" />
          <ProjectReference Include="..\TILSOFTAI.Orchestration\TILSOFTAI.Orchestration.csproj" />
          <ProjectReference Include="..\TILSOFTAI.Infrastructure\TILSOFTAI.Infrastructure.csproj" />
        </ItemGroup>
      </Project>

  files:
    #---------------------------------------------------------------------------
    # AnalyticsModule.cs
    #---------------------------------------------------------------------------
    - path: "src/TILSOFTAI.Modules.Analytics/AnalyticsModule.cs"
      action: "CREATE"
      description: "Module entry point"
      content: |
        using Microsoft.Extensions.DependencyInjection;
        using TILSOFTAI.Modules.Analytics.Tools;
        using TILSOFTAI.Orchestration.Modules;
        using TILSOFTAI.Orchestration.Tools;

        namespace TILSOFTAI.Modules.Analytics;

        /// <summary>
        /// Analytics module for deep analytics workflow with Schema RAG.
        /// </summary>
        public sealed class AnalyticsModule : ITilsoftModule
        {
            public string Name => "Analytics";
            public string Version => "1.0.0";

            public void ConfigureServices(IServiceCollection services)
            {
                // Register tool handlers
                services.AddScoped<CatalogSearchToolHandler>();
                services.AddScoped<CatalogGetDatasetToolHandler>();
                services.AddScoped<AnalyticsValidatePlanToolHandler>();
            }

            public void RegisterTools(IToolRegistry registry)
            {
                // Tools are registered from ToolCatalog via SQL seed
                // Handlers are resolved by name from DI
                
                registry.RegisterHandler("catalog_search", typeof(CatalogSearchToolHandler));
                registry.RegisterHandler("catalog_get_dataset", typeof(CatalogGetDatasetToolHandler));
                registry.RegisterHandler("analytics_validate_plan", typeof(AnalyticsValidatePlanToolHandler));
            }
        }

    #---------------------------------------------------------------------------
    # AnalyticsToolHandlerBase.cs
    #---------------------------------------------------------------------------
    - path: "src/TILSOFTAI.Modules.Analytics/Tools/AnalyticsToolHandlerBase.cs"
      action: "CREATE"
      description: "Base class cho Analytics tool handlers"
      content: |
        using System.Text.Json;
        using Microsoft.Extensions.Logging;
        using TILSOFTAI.Domain.ExecutionContext;
        using TILSOFTAI.Orchestration.Sql;
        using TILSOFTAI.Orchestration.Tools;

        namespace TILSOFTAI.Modules.Analytics.Tools;

        /// <summary>
        /// Base class for Analytics module tool handlers.
        /// Provides common SP execution pattern.
        /// </summary>
        public abstract class AnalyticsToolHandlerBase : IToolHandler
        {
            protected readonly ISqlExecutor SqlExecutor;
            protected readonly IExecutionContextAccessor ContextAccessor;
            protected readonly ILogger Logger;

            protected AnalyticsToolHandlerBase(
                ISqlExecutor sqlExecutor,
                IExecutionContextAccessor contextAccessor,
                ILogger logger)
            {
                SqlExecutor = sqlExecutor ?? throw new ArgumentNullException(nameof(sqlExecutor));
                ContextAccessor = contextAccessor ?? throw new ArgumentNullException(nameof(contextAccessor));
                Logger = logger ?? throw new ArgumentNullException(nameof(logger));
            }

            public abstract string ToolName { get; }

            public abstract Task<string> ExecuteAsync(
                ToolDefinition tool,
                string argumentsJson,
                TilsoftExecutionContext context,
                CancellationToken ct);

            protected async Task<string> ExecuteSpAsync(
                string spName,
                Dictionary<string, object?> parameters,
                CancellationToken ct)
            {
                var context = ContextAccessor.Current;
                
                // Always inject TenantId from context
                if (!parameters.ContainsKey("TenantId"))
                {
                    parameters["TenantId"] = context?.TenantId ?? throw new InvalidOperationException("TenantId is required");
                }

                Logger.LogDebug(
                    "ExecutingSP | SpName: {SpName} | ParamCount: {ParamCount}",
                    spName, parameters.Count);

                var result = await SqlExecutor.ExecuteToJsonAsync(spName, parameters, ct);
                
                Logger.LogDebug(
                    "SPExecuted | SpName: {SpName} | ResultLength: {Length}",
                    spName, result?.Length ?? 0);

                return result ?? "{}";
            }

            protected static T? ParseArguments<T>(string argumentsJson) where T : class
            {
                if (string.IsNullOrWhiteSpace(argumentsJson))
                    return null;

                return JsonSerializer.Deserialize<T>(argumentsJson, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                });
            }
        }

    #---------------------------------------------------------------------------
    # CatalogSearchToolHandler.cs
    #---------------------------------------------------------------------------
    - path: "src/TILSOFTAI.Modules.Analytics/Tools/CatalogSearchToolHandler.cs"
      action: "CREATE"
      description: "Handler cho catalog_search tool"
      content: |
        using Microsoft.Extensions.Logging;
        using TILSOFTAI.Domain.ExecutionContext;
        using TILSOFTAI.Orchestration.Sql;
        using TILSOFTAI.Orchestration.Tools;

        namespace TILSOFTAI.Modules.Analytics.Tools;

        /// <summary>
        /// Handler for catalog_search tool - Schema RAG search.
        /// </summary>
        public sealed class CatalogSearchToolHandler : AnalyticsToolHandlerBase
        {
            public override string ToolName => "catalog_search";

            public CatalogSearchToolHandler(
                ISqlExecutor sqlExecutor,
                IExecutionContextAccessor contextAccessor,
                ILogger<CatalogSearchToolHandler> logger)
                : base(sqlExecutor, contextAccessor, logger)
            {
            }

            public override async Task<string> ExecuteAsync(
                ToolDefinition tool,
                string argumentsJson,
                TilsoftExecutionContext context,
                CancellationToken ct)
            {
                var args = ParseArguments<CatalogSearchArgs>(argumentsJson);
                
                if (string.IsNullOrWhiteSpace(args?.Query))
                {
                    throw new ArgumentException("Query is required for catalog_search");
                }

                var parameters = new Dictionary<string, object?>
                {
                    ["TenantId"] = context.TenantId,
                    ["Query"] = args.Query,
                    ["TopK"] = args.TopK ?? 5,
                    ["Domain"] = args.Domain ?? "internal"
                };

                return await ExecuteSpAsync("dbo.ai_catalog_search", parameters, ct);
            }

            private sealed class CatalogSearchArgs
            {
                public string? Query { get; set; }
                public int? TopK { get; set; }
                public string? Domain { get; set; }
            }
        }

    #---------------------------------------------------------------------------
    # CatalogGetDatasetToolHandler.cs
    #---------------------------------------------------------------------------
    - path: "src/TILSOFTAI.Modules.Analytics/Tools/CatalogGetDatasetToolHandler.cs"
      action: "CREATE"
      description: "Handler cho catalog_get_dataset tool"
      content: |
        using Microsoft.Extensions.Logging;
        using TILSOFTAI.Domain.ExecutionContext;
        using TILSOFTAI.Orchestration.Sql;
        using TILSOFTAI.Orchestration.Tools;

        namespace TILSOFTAI.Modules.Analytics.Tools;

        /// <summary>
        /// Handler for catalog_get_dataset tool - Get full dataset schema.
        /// </summary>
        public sealed class CatalogGetDatasetToolHandler : AnalyticsToolHandlerBase
        {
            public override string ToolName => "catalog_get_dataset";

            public CatalogGetDatasetToolHandler(
                ISqlExecutor sqlExecutor,
                IExecutionContextAccessor contextAccessor,
                ILogger<CatalogGetDatasetToolHandler> logger)
                : base(sqlExecutor, contextAccessor, logger)
            {
            }

            public override async Task<string> ExecuteAsync(
                ToolDefinition tool,
                string argumentsJson,
                TilsoftExecutionContext context,
                CancellationToken ct)
            {
                var args = ParseArguments<CatalogGetDatasetArgs>(argumentsJson);
                
                if (string.IsNullOrWhiteSpace(args?.DatasetKey))
                {
                    throw new ArgumentException("DatasetKey is required for catalog_get_dataset");
                }

                var parameters = new Dictionary<string, object?>
                {
                    ["TenantId"] = context.TenantId,
                    ["DatasetKey"] = args.DatasetKey
                };

                return await ExecuteSpAsync("dbo.ai_catalog_get_dataset", parameters, ct);
            }

            private sealed class CatalogGetDatasetArgs
            {
                public string? DatasetKey { get; set; }
            }
        }

    #---------------------------------------------------------------------------
    # AnalyticsValidatePlanToolHandler.cs
    #---------------------------------------------------------------------------
    - path: "src/TILSOFTAI.Modules.Analytics/Tools/AnalyticsValidatePlanToolHandler.cs"
      action: "CREATE"
      description: "Handler cho analytics_validate_plan tool"
      content: |
        using System.Text.Json;
        using Microsoft.Extensions.Logging;
        using TILSOFTAI.Domain.ExecutionContext;
        using TILSOFTAI.Orchestration.Sql;
        using TILSOFTAI.Orchestration.Tools;

        namespace TILSOFTAI.Modules.Analytics.Tools;

        /// <summary>
        /// Handler for analytics_validate_plan tool - Validate atomic plan before execution.
        /// </summary>
        public sealed class AnalyticsValidatePlanToolHandler : AnalyticsToolHandlerBase
        {
            public override string ToolName => "analytics_validate_plan";

            public AnalyticsValidatePlanToolHandler(
                ISqlExecutor sqlExecutor,
                IExecutionContextAccessor contextAccessor,
                ILogger<AnalyticsValidatePlanToolHandler> logger)
                : base(sqlExecutor, contextAccessor, logger)
            {
            }

            public override async Task<string> ExecuteAsync(
                ToolDefinition tool,
                string argumentsJson,
                TilsoftExecutionContext context,
                CancellationToken ct)
            {
                var args = ParseArguments<ValidatePlanArgs>(argumentsJson);
                
                if (args?.PlanJson == null)
                {
                    throw new ArgumentException("PlanJson is required for analytics_validate_plan");
                }

                // Serialize planJson object to string for SP
                var planJsonString = args.PlanJson is JsonElement element
                    ? element.GetRawText()
                    : JsonSerializer.Serialize(args.PlanJson);

                var parameters = new Dictionary<string, object?>
                {
                    ["TenantId"] = context.TenantId,
                    ["PlanJson"] = planJsonString
                };

                return await ExecuteSpAsync("dbo.ai_analytics_validate_plan", parameters, ct);
            }

            private sealed class ValidatePlanArgs
            {
                public object? PlanJson { get; set; }
            }
        }

    #---------------------------------------------------------------------------
    # README.md
    #---------------------------------------------------------------------------
    - path: "src/TILSOFTAI.Modules.Analytics/README.md"
      action: "CREATE"
      description: "Module documentation"
      content: |
        # TILSOFTAI.Modules.Analytics

        Deep Analytics module implementing Schema RAG workflow for LLM-driven data analysis.

        ## Overview

        This module provides tools for LLM to:
        1. **Discover schemas** via catalog tools (Schema RAG)
        2. **Validate plans** before execution
        3. **Execute analytics** via atomic engine

        ## Tools

        | Tool | SP Name | Purpose |
        |------|---------|---------|
        | `catalog_search` | `ai_catalog_search` | Search datasets/fields by query |
        | `catalog_get_dataset` | `ai_catalog_get_dataset` | Get full schema for a dataset |
        | `analytics_validate_plan` | `ai_analytics_validate_plan` | Validate plan before execution |

        ## Workflow

        ```
        User Question
            -> Normalize (deterministic)
            -> catalog_search (find datasets)
            -> catalog_get_dataset (get schema)
            -> Build atomic plan (LLM)
            -> analytics_validate_plan
            -> atomic_execute_plan
            -> Insight Assembly
            -> Response
        ```

        ## Configuration

        ```json
        {
          "Analytics": {
            "MaxRows": 200,
            "MaxGroupBy": 4,
            "MaxMetrics": 3,
            "MaxJoins": 1,
            "MaxPlanRetries": 2,
            "EnableInsightCache": true
          }
        }
        ```

###############################################################################
# PHASE 6: ENABLE AND TEST
###############################################################################

phase_6_enable_and_test:
  config_updates:
    #---------------------------------------------------------------------------
    # appsettings.json update
    #---------------------------------------------------------------------------
    - file: "src/TILSOFTAI.Api/appsettings.json"
      action: "MODIFY"
      description: "Add Analytics module to enabled modules and add Analytics section"
      instructions:
        - operation: "ADD_TO_ARRAY"
          path: "$.Modules.Enabled"
          value: "TILSOFTAI.Modules.Analytics"
        - operation: "ADD_SECTION"
          path: "$"
          key: "Analytics"
          value:
            MaxRows: 200
            MaxGroupBy: 4
            MaxMetrics: 3
            MaxJoins: 1
            MaxTimeWindowDays: 366
            AllowedMetricOps: ["count", "countDistinct", "sum", "avg", "min", "max"]
            MaxPlanRetries: 2
            EnableTaskFramePersistence: true
            EnableInsightCache: true
            InsightCacheTtlSeconds: 300

  solution_update:
    - file: "TILSOFTAI.slnx"
      action: "MODIFY"
      description: "Add Analytics module project to solution"
      instructions:
        - operation: "ADD_PROJECT"
          path: "src/TILSOFTAI.Modules.Analytics/TILSOFTAI.Modules.Analytics.csproj"

###############################################################################
# VALIDATION CHECKLIST
###############################################################################

validation_checklist:
  pre_deployment:
    - check: "All SQL scripts have CREATE OR ALTER or IF NOT EXISTS"
      required: true
    - check: "All ai_* SPs accept @TenantId"
      required: true
    - check: "All ai_* SPs return JSON envelope"
      required: true
    - check: "ToolCatalog seeds have valid JsonSchema"
      required: true
    - check: "C# project compiles with TreatWarningsAsErrors"
      required: true
    - check: "No hardcoded domain logic in C#"
      required: true

  post_deployment:
    - check: "Module loads without errors"
      required: true
    - check: "Tools appear in tool catalog"
      required: true
    - check: "catalog_search returns results"
      required: true
    - check: "atomic_execute_plan works with new tools"
      required: true

###############################################################################
# ROLLBACK INSTRUCTIONS
###############################################################################

rollback:
  description: "If issues occur, rollback in reverse order"
  steps:
    - "Remove Analytics from Modules.Enabled in appsettings.json"
    - "DROP tables: AnalyticsTaskFrame, AnalyticsPlanValidationError, AnalyticsInsightCache"
    - "DROP views: v_Analytics_*"
    - "DROP procedures: ai_catalog_*, ai_analytics_*, app_analytics_*"
    - "DELETE FROM ToolCatalog WHERE ToolName IN ('catalog_search', 'catalog_get_dataset', 'analytics_validate_plan')"
    - "DELETE FROM MetadataDictionary WHERE [Key] LIKE 'analytics.%'"
    - "Remove TILSOFTAI.Modules.Analytics project folder"

###############################################################################
# END OF PATCH PACK
###############################################################################
